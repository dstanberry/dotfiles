#!/usr/bin/env zsh

create_detached_session() {
  (TMUX='' tmux new-session -Ad -s "$session_name" -c "$dir")
}

create_if_needed_and_attach() {
  if not_in_tmux; then
    tmux new-session -As "$session_name" -c "$dir"
  else
    session_exists || create_detached_session
    tmux switch-client -t "$session_name"
  fi
}

session_exists() {
  tmux list-sessions 2>/dev/null | sed -E 's/:.*$//' | grep -q "^$session_name$"
}

not_in_tmux() {
  [[ -z "$TMUX" ]]
}

# ----------------------------- Helpers ----------------------------- #

_pick_directory() {
  _get_session_dirs() {
    local -a project_dirs worktree_dirs
    local res_a res_b

    _get_worktrees() {
      local repo="$1" list
      [[ -d $repo ]] || return 0
      if [[ -d $repo/worktrees || -d $repo/.git/worktrees ]]; then
        list=$(git -C "$repo" worktree list 2>/dev/null | awk '{print $1}')
        [[ -n $list ]] || return 0
        print -rl -- $list
      fi
    }

    for d in "$HOME"/Git/*; do
      [[ -d $d ]] || continue
      while IFS= read -r w; do worktree_dirs+="$w"; done < <(_get_worktrees "$d")
    done
    for d in "$HOME"/Projects/*/*; do
      [[ -d $d ]] || continue
      project_dirs+="$d"
      while IFS= read -r w; do worktree_dirs+="$w"; done < <(_get_worktrees "$d")
    done
    res_a=$(find -L "$HOME/Git" "$HOME/Projects" -maxdepth 1 -type d 2>/dev/null)
    res_b=$(find -L "${XDG_CONFIG_HOME}" ${project_dirs:+"${project_dirs[@]}"} \
      ${worktree_dirs:+"${worktree_dirs[@]}"} -maxdepth 0 -type d 2>/dev/null)
    printf '%s\n%s\n' "$res_a" "$res_b" | sort -V | uniq
  }

  _get_session_dirs | fzf \
    --height='100%' \
    --reverse --header='Create/Open Session' \
    --preview '(glow -s dark {1}/README.md || \
          bat --style=plain {1}/README.md || \
          cat {1}/README.md || \
          eza -lh --color=always --icons --git {1} || \
          ls -lh {1}) 2> /dev/null'
}

_show_scrollback() {
  local file
  file="$(mktemp).sh"
  tmux capture-pane -pS -32768 > "$file"
  tmux new-window -n:scrollback "nvim -c \"lua require('util.window').term_scrollback()\" $file"
}

_toggle_float() {
  local current
  current="$(tmux display-message -p -F '#{session_name}')"
  if [[ $current == float-repl ]]; then
    tmux detach-client
  else
    tmux popup -d '#{pane_current_path}' -xC -yC -w90% -h80% \
      -E "tmux attach -t float-repl || tmux new -s float-repl" || true
  fi
}

_next_session() {
  if not_in_tmux; then
    echo "command only available within tmux" >&2
    return 1
  fi
  local -a available_clients
  local current_client next_index=0
  available_clients=("${(@f)$(tmux list-sessions -F '#S' | grep -v '^float-repl')}")
  current_client="$(tmux display-message -p -F '#{session_name}')"
  [[ $current_client == float-repl ]] && {
    tmux display-message 'Client switch not allowed in this session'
    return 0
  }
  (( ${#available_clients[@]} == 1 )) && {
    tmux display-message "Can't switch to next client"
    return 0
  }
  for idx in {1..$(( ${#available_clients[@]} ))}; do
    [[ ${available_clients[$idx]} == "$current_client" ]] && next_index=$((idx + 1))
  done
  (( next_index > ${#available_clients[@]} )) && next_index=1
  tmux switch-client -t "${available_clients[$next_index]}"
}

_previous_session() {
  if not_in_tmux; then
    echo "command only available within tmux" >&2
    return 1
  fi
  local -a available_clients
  local current_client next_index
  available_clients=("${(@f)$(tmux list-sessions -F '#S' | grep -v '^float-repl')}")
  current_client="$(tmux display-message -p -F '#{session_name}')"
  [[ $current_client == float-repl ]] && {
    tmux display-message 'Client switch not allowed in this session'
    return 0
  }
  (( ${#available_clients[@]} == 1 )) && {
    tmux display-message "Can't switch to previous client"
    return 0
  }
  next_index=${#available_clients[@]}
  for idx in {1..$(( ${#available_clients[@]} ))}; do
    [[ ${available_clients[$idx]} == "$current_client" ]] && next_index=$((idx - 1))
  done
  (( next_index <= 0 )) && next_index=$(( ${#available_clients[@]} ))
  tmux switch-client -t "${available_clients[next_index]}"
}

# --------------------------- Argument Parse ------------------------ #

if (( $# == 0 )); then
  dir=$PWD
elif (( $# == 1 )); then
  case "$1" in
    new) dir=$(_pick_directory); [[ -z "$dir" ]] && exit 0 ;;
    next) _next_session && exit 0 ;;
    previous) _previous_session && exit 0 ;;
    show-scrollback) _show_scrollback && exit 0 ;;
    toggle-float) _toggle_float && exit 0 ;;
    *)
      echo "'$1' is not a supported argument at this time" >&2
      exit 1 ;;
  esac
else
  echo "unsupported number of arguments: 0 or 1 expected, got $#" >&2
  exit 1
fi

# --------------------------- Session Attach ------------------------ #

session_name="$(basename "$dir" | tr . _)"
create_if_needed_and_attach
