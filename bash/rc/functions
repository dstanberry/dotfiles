# poor man's ag runtime configuration
function ag() {
	command ag --pager="less -iFMRSX" --color-path=34\;3 --color-line-number=33 --color-match=35\;1\;4 "$@"
}

# interactively delete filename(s) by name
function del() {
	if [ $# -eq 0 ]; then
		echo "error: at least one argument is required"
		return 1
	fi

	local filename=$1

	if [[ $filename == .* ]]; then
		filename=${filename/#/\\}
	fi

	if [ $# -eq 2 ]; then
		fd "^${filename}$" $2 -tf -X rm -i
	else
		fd "^${filename}$" -tf -X rm -i
	fi
}

# poor man's fd runtime configuration
function fd() {
	command fd -H "$@"
}

# find in history
function fh() {
	print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed -r 's/ *[0-9]*\*? *//' | sed -r 's/\\/\\\\/g')
}

# add subcommand to git
function git() {
	if [ "$1" = root ]; then
		shift
		local ROOT="$(command git rev-parse --show-toplevel 2> /dev/null || echo -n .)"
		if [ $# -eq 0 ]; then
			cd "$ROOT"
		else
			(cd "$ROOT" && eval "$@")
		fi
	else
		command git "$@"
	fi
}

# print response headers, following redirects.
function headers() {
  emulate -L zsh

  if [ $# -ne 1 ]; then
    echo "error: a host argument is required"
    return 1
  fi

  local REMOTE=$1

  curl -sSL -D - "$REMOTE" -o /dev/null
}

# poor man's rg runtime configuration
function rg()
{
	command rg --colors line:fg:yellow --colors line:style:bold --colors path:fg:blue --colors path:style:bold --colors match:fg:magenta --colors match:style:underline -p "$@" | less -iFMRSX
}

# display information about a remote ssl certificate
function ssl() {
	if [ $# -eq 0 ]; then
		echo "error: a host argument is required"
		return 1
	fi

	local REMOTE=$1

	if [ $# -eq 2 ];then
		local PORT=$2

		echo | openssl s_client -showcerts -servername "$REMOTE" -connect "$REMOTE:$PORT" 2>/dev/null | openssl x509 -inform pem -noout -text
	else

		echo | openssl s_client -showcerts -servername "$REMOTE" -connect "$REMOTE:443" 2>/dev/null | openssl x509 -inform pem -noout -text
	fi
}

# print a pruned version of a tree
function subtree() {
	tree -a --prune -P "$@"
}
# try to run tmux with session management
function tmx() {
	# make sure even pre-existing tmux sessions use the latest SSH_AUTH_SOCK.
	local SOCK_SYMLINK=~/.ssh/ssh_auth_sock
	if [ -r "$SSH_AUTH_SOCK" -a ! -L "$SSH_AUTH_SOCK" ]; then
		ln -sf "$SSH_AUTH_SOCK" $SOCK_SYMLINK
	fi

	# if provided with args, pass them through.
	if [[ -n "$@" ]]; then
		env SSH_AUTH_SOCK=$SOCK_SYMLINK tmux "$@"
		return
	fi

	# check for .tmux file (poor man's tmuxinator).
	if [ -x .tmux ]; then
		# prompt the first time we see a given .tmux file before running it.
		local DIGEST="$(openssl dgst -sha512 .tmux)"
		if ! grep -q "$DIGEST" ${TMUX_CONFIG_HOME}/tmux.digests 2> /dev/null; then
			cat .tmux
			read -k 1 -r \
			'REPLY?Trust (and run) this .tmux file? (t = trust, otherwise = skip) '
			echo
			if [[ $REPLY =~ ^[Tt]$ ]]; then
				echo "$DIGEST" >> ${TMUX_CONFIG_HOME}/tmux.digests
				./.tmux
				return
			fi
		else
			./.tmux
			return
		fi
	fi

	# attach to existing session, or create one, based on current directory.
	local SESSION_NAME=$(basename "${$(pwd)//[.:]/_}")
	env SSH_AUTH_SOCK=$SOCK_SYMLINK tmux new -A -s "$SESSION_NAME"
}

# cd to specially hashed directories from anywhere on the filesystem
function jump() {
	if [ $# -eq 0 ]; then
		fd
	else
		local DIR="${*%%/}"

		if [ $(hash -d|cut -d= -f1|grep -c "^${DIR}\$") = 0 ]; then
			# not in `hash -d`: use as initial argument to fd.
			fd "$*"
		else
			cd ~"$DIR"
		fi
	fi
}

# enable autocomplete for hashed directories
function _jump_complete() {
	local COMPLETIONS
	COMPLETIONS="$(hash -d | cut -d= -f1)"
	reply=( "${(ps:\n:)COMPLETIONS}" )
}

# list contents of specially hashed directories from anywhere on the filesystem
function show() {
	emulate -L zsh

	if [ $# -eq 0 ]; then
		fd
	else
		local DIR="${*%%/}"

		if [ $(hash -d|cut -d= -f1|grep -c "^${DIR}\$") = 0 ]; then
			# not in `hash -d`: use as initial argument to fd.
			fd "$*"
		else
			ls ~"$DIR"
		fi
	fi
}

# enable autocomplete for hashed directories
function _show_complete() {
	emulate -L zsh

	local COMPLETIONS
	COMPLETIONS="$(hash -d|cut -d= -f1)"
	reply=( "${(ps:\n:)COMPLETIONS}" )
}

# complete filenames and `hash -d` entries.
compctl -f -K _show_complete show
