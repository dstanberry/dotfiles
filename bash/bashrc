###############################################################
# Directories
###############################################################
# base directory for configuration files
CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# base directory for bash configuration files
BASH_CONFIG_HOME="${CONFIG_HOME}/bash"

# base directory for tmux bash configuration files
TMUX_CONFIG_HOME="${CONFIG_HOME}/tmux"

# base directory for (n)vim configuration files
VIM_CONFIG_HOME="${CONFIG_HOME}/vim"

# include helper functions
source "${CONFIG_HOME}/scripts/helpers.sh"

# ensure bash cache dir exists
if [ ! -d "${HOME}"/.cache/bash ]; then
  mkdir -p "${HOME}"/.cache/bash
fi

# ensure that local binaries are available
if [ ! -d "${HOME}"/.local/bin ]; then
  mkdir -p "${HOME}"/.local/bin
fi

# ensure less cache dir exists
if [ ! -d "${HOME}"/.cache/less ]; then
  mkdir -p "${HOME}"/.cache/less
fi

# ensure less wrapper exists in PATH
if [ ! -L "${HOME}"/.local/bin/menos ]; then
  ln -s "${CONFIG_HOME}"/less/menos "${HOME}"/.local/bin/menos
fi

# include wsl scripts where appropriate
if is_wsl; then
  for file in "${CONFIG_HOME}"/wsl/*; do
    f=$(basename "$file")
    if [ ! -L "${HOME}"/.local/bin/"$f" ]; then
      ln -s "$file" "${HOME}"/.local/bin/"$f"
    fi
  done
fi

# ensure general purpose scripts exists in PATH
for file in "${CONFIG_HOME}"/bin/*; do
  f=$(basename "$file")
  if [ ! -L "${HOME}"/.local/bin/"$f" ]; then
    ln -s "$file" "${HOME}"/.local/bin/"$f"
  fi
done

# ensure there are no broken symlinks
find "${HOME}"/.local/bin -type l ! -exec test -e {} \; -delete

# ensure that vim packages directories exist
if [ ! -d "${VIM_CONFIG_HOME}"/remote ]; then
  mkdir -p "${VIM_CONFIG_HOME}"/remote
fi

# ensure that bash private directories exist
if [ ! -d "${BASH_CONFIG_HOME}"/rc.private ]; then
  mkdir -p "${BASH_CONFIG_HOME}"/rc.private
fi

###############################################################
# General Options
###############################################################
# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=4

# enable history expansion with space
bind Space:magic-space

# turn on recursive globbing (enables ** to recurse all directories)
shopt -s globstar 2> /dev/null

# case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob

# disable the system bell
bind "set bell-style none"

# keymap to clear scrollback buffer
bind -x '"\C-l": clear'

###############################################################
# Tab Completion
###############################################################
# perform file completion in a case insensitive fashion
bind "set completion-ignore-case on"

# treat hyphens and underscores as equivalent
bind "set completion-map-case on"

# display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

# immediately add a trailing slash when autocompleting symlinks to directories
bind "set mark-symlinked-directories on"

###############################################################
# History
###############################################################
# append to the history file, don't overwrite it
shopt -s histappend

# save multi-line commands as one command
shopt -s cmdhist

# record each line as it gets issued
PROMPT_COMMAND='history -a'

# define max recording length for history
HISTSIZE=500000
HISTFILESIZE=100000

# enable incremental history search with up/down arrows
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

###############################################################
# Navigation
###############################################################
# prepend cd to directory names automatically
shopt -s autocd 2> /dev/null

# auto-correct spelling errors during tab-completion
shopt -s dirspell 2> /dev/null
# auto-correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

# colon-separated list of directories that define the base directory for
# arbitrary cd commands
CDPATH="."

# list directory contents after changing to it
function cd() {
  builtin cd "$@" &> /dev/null || exit
  ls --color=auto --ignore=ntuser\.* \
    --ignore=NTUSER\.* --almost-all --group-directories-first
}

###############################################################
# Color
###############################################################
# enable dircolors if it is available
if hash dircolors 2> /dev/null; then
  test -r "${CONFIG_HOME}"/shared/dircolors \
    && eval "$(dircolors -b "${CONFIG_HOME}"/shared/dircolors)" \
    || eval "$(dircolors -b)"
fi

###############################################################
# Workspace
###############################################################
# load runtime configuration files
if [ -d "$BASH_CONFIG_HOME/rc" ]; then
  for RC_FILE in $(find "$BASH_CONFIG_HOME"/rc -type f | sort); do
    source "$RC_FILE"
  done
fi

###############################################################
# Shell Prompt
###############################################################
# load prompt definitions
test -s "${BASH_CONFIG_HOME}/prompt.bash" \
  && source "${BASH_CONFIG_HOME}/prompt.bash"

###############################################################
# fzf
###############################################################
if hash fzf 2> /dev/null; then
  # load fzf keybinds
  test -s "${BASH_CONFIG_HOME}/plugins/fzf/key-bindings.bash" \
    && source "${BASH_CONFIG_HOME}/plugins/fzf/key-bindings.bash"

  # load fzf completion
  test -s "${BASH_CONFIG_HOME}/plugins/fzf/completion.bash" \
    && source "${BASH_CONFIG_HOME}/plugins/fzf/completion.bash"
fi

###############################################################
# git
###############################################################
# load git completion
test -s "${BASH_CONFIG_HOME}/plugins/git/git-completion.bash" \
  && source "${BASH_CONFIG_HOME}/plugins/git/git-completion.bash"

###############################################################
# _Custom
###############################################################
# check for machine-specific rc files and source them if available
if [ -d "$BASH_CONFIG_HOME/rc.private" ]; then
  for RC_FILE in $(find "$BASH_CONFIG_HOME"/rc.private -type f | sort); do
    source "$RC_FILE"
  done
fi
