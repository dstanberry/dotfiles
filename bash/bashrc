###############################################################
# Directories
###############################################################
# base directory for configuration files
CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# base directory for bash configuration files
BASH_CONFIG_HOME="${CONFIG_HOME}/bash"

# base directory for tmux bash configuration files
TMUX_CONFIG_HOME="${CONFIG_HOME}/tmux"

# base directory for vim configuration files
VIM_CONFIG_HOME="${CONFIG_HOME}/vim"

# include helper functions
source ${CONFIG_HOME}/scripts/helpers.sh

# ensure that local binaries are available
if [ ! -d ${HOME}/.local/bin ]; then
	mkdir -p ${HOME}/.local/bin;
fi

# ensure less wrapper exists in PATH
if [ ! -L ${HOME}/.local/bin/menos ]; then
	ln -s ${CONFIG_HOME}/less/menos ${HOME}/.local/bin/menos;
fi

# in wsl environments, ensure clipboard scripts exist in PATH
if is_wsl; then
	for file in $(ls ${CONFIG_HOME}/wsl)
	do
		if [ ! -L ${HOME}/.local/bin/$file ]; then
			ln -s ${CONFIG_HOME}/wsl/$file ${HOME}/.local/bin/$file;
		fi
	done
fi

# ensure general purpose scripts exists in PATH
for file in $(ls ${CONFIG_HOME}/bin)
do
	if [ ! -L ${HOME}/.local/bin/$file ]; then
		ln -s ${CONFIG_HOME}/bin/$file ${HOME}/.local/bin/$file;
	fi
done

# ensure there are no broken symlinks
find ${HOME}/.local/bin -type l ! -exec test -e {} \; -delete

# ensure tmux configuration exists
if [ ! -L ${HOME}/.tmux.conf ]; then
	ln -s ${TMUX_CONFIG_HOME}/tmux.conf ${HOME}/.tmux.conf
fi

# ensure that vim packages directories exist
if [ ! -d ${VIM_CONFIG_HOME}/pack/remote/opt ]; then
	mkdir -p ${VIM_CONFIG_HOME}/pack/remote/opt;
fi

# ensure that vim backup directory exists
if [ ! -d ${VIM_CONFIG_HOME}/tmp/backup ]; then
	mkdir -p ${VIM_CONFIG_HOME}/tmp/backup;
fi

# ensure that vim netrw directory exists
if [ ! -d ${VIM_CONFIG_HOME}/tmp/netrw ]; then
	mkdir -p ${CONFIG_HOME}/vim/tmp/netrw;
fi

# ensure that vim swap directory exists
if [ ! -d ${VIM_CONFIG_HOME}/tmp/swap ]; then
	mkdir -p ${VIM_CONFIG_HOME}/tmp/swap;
fi

# ensure that vim undo directory exists
if [ ! -d ${VIM_CONFIG_HOME}/tmp/undo ]; then
	mkdir -p ${VIM_CONFIG_HOME}/tmp/undo;
fi

# ensure that bash private directories exist
if [ ! -d ${BASH_CONFIG_HOME}/rc.private ]; then
	mkdir -p ${BASH_CONFIG_HOME}/rc.private;
fi

###############################################################
# General Options
###############################################################
# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=4

# enable history expansion with space
bind Space:magic-space

# turn on recursive globbing (enables ** to recurse all directories)
shopt -s globstar 2> /dev/null

# case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob;

# disable the system bell
bind "set bell-style none"

# keymap to clear scrollback buffer
bind -x '"\C-l": clear'

###############################################################
# Tab Completion
###############################################################
# perform file completion in a case insensitive fashion
bind "set completion-ignore-case on"

# treat hyphens and underscores as equivalent
bind "set completion-map-case on"

# display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

# immediately add a trailing slash when autocompleting symlinks to directories
bind "set mark-symlinked-directories on"

###############################################################
# History
###############################################################
# append to the history file, don't overwrite it
shopt -s histappend

# save multi-line commands as one command
shopt -s cmdhist

# record each line as it gets issued
PROMPT_COMMAND='history -a'

# define max recording length for history
HISTSIZE=500000
HISTFILESIZE=100000

# enable incremental history search with up/down arrows
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

###############################################################
# Navigation
###############################################################
# prepend cd to directory names automatically
shopt -s autocd 2> /dev/null

# auto-correct spelling errors during tab-completion
shopt -s dirspell 2> /dev/null
# auto-correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

# colon-separated list of directories that define the base directory for
# arbitrary cd commands
CDPATH="."

# list directory contents after changing to it
function cd() {
	builtin cd "$@" &> /dev/null
	ls --color=auto --ignore=ntuser\.* \
	--ignore=NTUSER\.* --almost-all --group-directories-first
}

###############################################################
# Color
###############################################################
# enable dircolors if it is available
if hash dircolors 2>/dev/null; then
	test -r ${BASH_CONFIG_HOME}/dircolors && \
	eval "$(dircolors -b ${BASH_CONFIG_HOME}/dircolors)" \
	|| eval "$(dircolors -b)"
fi

###############################################################
# Workspace
###############################################################
# load runtime configuration files
if [ -d "$BASH_CONFIG_HOME/rc" ]; then
	for RC_FILE in $(find $BASH_CONFIG_HOME/rc -type f | sort); do
		source "$RC_FILE"
	done
fi

###############################################################
# Shell Prompt
###############################################################
# load prompt definitions
test -s "${BASH_CONFIG_HOME}/prompt.bash" && \
source "${BASH_CONFIG_HOME}/prompt.bash"

###############################################################
# fzf
###############################################################
if hash fzf 2>/dev/null; then
	# load fzf keybinds
	test -s "${BASH_CONFIG_HOME}/plugins/fzf" && \
	source "${BASH_CONFIG_HOME}/plugins/fzf"
fi

###############################################################
# _Custom
###############################################################
# check for machine-specific rc files and source them if available
if [ -d "$BASH_CONFIG_HOME/rc.private" ]; then
	for RC_FILE in $(find $BASH_CONFIG_HOME/rc -type f | sort); do
		source "$RC_FILE"
	done
fi
